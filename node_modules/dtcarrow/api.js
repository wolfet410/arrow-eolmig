// Library code specifically for api support and plugin.js code
var Arrow = require('arrow'),
    Dtcarrow = require('dtcarrow'),
    Q = require('q'),
    atob = require('atob'),
    Moment = require('moment'),
    Crypto = require('crypto'),
    Constants = require('./constants');

module.exports.getApiDetails = function(apipath, method) {
    // Searches Api table for an API by path & method, uses callback (err, data) pattern
    // Also handles the wild card (*) character that may or may not be included in the 
    // path listed in the Api table
    var deferred = Q.defer();

    var query = 'SELECT * FROM Api WHERE method = "' + method + '" AND '
        + '(url = "' + apipath + '" OR ';
    var s = apipath.split('/');
    var l = s.length;
    // One asterisk
    for (var c = 1; c < l; c++) {
        var newpath = '';
        for (var i = 1; i < l; i++) {
            newpath += '/';
            if (c === i) {
                newpath += '*';
            } else {
                newpath += s[i];
            }
        }
        query += 'url = "' + newpath + '" OR ';
    }

    // Handling common double asterisk patterns
    // query += 'url = "' + '/' + s[1] + '/' + s[2] + '/*/*" OR ';
    // query += 'url = "' + '/' + s[1] + '/' + s[2] + '/' + s[3] + '/*/*"';
    query += 'url = "' + '/' + s[1] + '/' + s[2] + '/' + s[3] + '/*/' + s[5] + '/*" OR ';
    query += 'url = "' + '/' + s[1] + '/' + s[2] + '/*/' + s[4] + '/*"';

    // query = query.substring(0, query.length - 3);
    query += ') ORDER BY `order` LIMIT 1';

    var Api = Arrow.getModel('appc.mysql.eolmig/Api');
    Api.query({ customSqlQuery: query }, function(err, apis) {
        if (err) {
            deferred.reject({ success: false, status: 500, caller: 'api.js>getApiDetails', data: err });
            return deferred.promise;
        }

        if (apis.length === 0) {
            deferred.reject({ success: false, status: 404, caller: 'api.js>getApiDetails', 
                data: 'API ' + apipath + ' not found in Api table' });
            return deferred.promise;
        }

        deferred.resolve({ success: true, status: 200, caller: 'api.js>getApiDetails', data: apis[0] });
    });

    return deferred.promise;
};

module.exports.getApiRoles = function(apidetails) {
    // Uses the api/roles API to get an APIs roles, and returns the 
    // apidetails object with the new roles
    var deferred = Q.defer();

    var Model = Arrow.getModel('appc.mysql.eolmig/ApiRole');
    Model.query({ apiId: apidetails.data.apiId }, function(err, roles) {
        if (err) {
            deferred.reject({ success: false, status: 500, caller: 'api.js>getApiRoles', data: err });
            return deferred.promise;
        }
        apidetails.data.roles = roles;
        deferred.resolve({ success: true, status: 200, caller: 'api.js>getApiRoles', data: apidetails.data });
    });

    return deferred.promise;
};

module.exports.getUserDetails = function(req) {
    // Wraps the user/current API in a promise so we can handle it
    var deferred = Q.defer();

    req.server.getAPI('/api/user/current', 'GET').execute({ clientapikey: req.headers['x-api-key'] }, function(err, currentresults) {
        if (err) {
            deferred.reject({ success: false, status: 500, caller: 'api.js>getUserDetails', data: err });
            return deferred.promise;
        }

        if (typeof currentresults === 'undefined' || currentresults.reduceduser.roles.length === 0) {
            // Users must have at least one role assigned to them
            deferred.reject({ success: false, status: 404, caller: 'api.js>getUserDetails', 
                data: 'No roles assigned to the current user' });
            return deferred.promise;
        }

        deferred.resolve({ success: true, status: 200, caller: 'api.js>getUserDetails', data: currentresults });
    });

    return deferred.promise;
};

module.exports.testExpiration = function(expiration) {
    // Checking expiration timestamp against current time, returns true if not expired, false otherwise
    if (typeof expiration === 'undefined') {
        return { success: false, status: 500, caller: 'api.js>testExpiration', 
                data: 'Missing expiration parameter' };
    }

    if (Moment.unix(expiration).isBefore(Moment())) {
        // Expired
        return { success: true, status: 200, caller: 'api.js>testExpiration', 
                data: false };
    } else {
        return { success: true, status: 200, caller: 'api.js>testExpiration', 
                data: true };
    }
};

module.exports.encryptApikey = function(apikey, expirationHours) {
    // Receives the Apikey and returns an encrypted clientApikey with
    // an expiration date
    if (typeof apikey === 'undefined' || typeof expirationHours !== 'number') {
        return { success: false, status: 500, caller: 'api.js>encryptApikey', 
                data: 'Missing apikey or bad expirationHours' };   
    }

    var expiration = Moment().add(expirationHours, 'hours').unix();

    // Encrypting Apikey
    var algorithm = 'aes256';
    try {
        var cipher = Crypto.createCipher(algorithm, Constants.CRYPTOKEY);
        var clientApikey = cipher.update(apikey + ':' + expiration, 'utf8', 'hex');
        clientApikey += cipher.final('hex');
    }
    catch(err) {
        return { success: false, status: 500, caller: 'api.js>encryptApikey', 
                data: 'Bad encryption:' + err };   
    }

    return { success: true, status: 200, caller: 'api.js>encryptApikey', 
                data: clientApikey };
};

module.exports.decryptClientApikey = function(clientApikey) {
    // Receives clientApikey and returns an object containing the 
    // decrypted apikey and its expiration date.
    // Returns a string containing the error message on failure.
    if (typeof clientApikey === 'undefined') {
        return { success: false, status: 500, caller: 'api.js>decryptClientApikey', 
                data: 'Missing clientApikey' };   
    }

    var algorithm = 'aes256';

    var decipher = Crypto.createDecipher(algorithm, Constants.CRYPTOKEY);
    try {
        var decrypted = decipher.update(clientApikey, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
    }
    catch(err) {
        return { success: false, status: 500, caller: 'api.js>decryptClientApikey', 
                data: 'Bad decryption:' + err };   
    }

    if (decrypted === null || decrypted.indexOf(':') === -1) {
        return { success: false, status: 500, caller: 'api.js>decryptClientApikey', 
                data: 'Empty or invalid decrypted text' };   
    }

    // Finding apikey & expiration timestamp
    var ds = decrypted.split(':');
    var apikey = ds[0];
    var expiration = ds[1];

    return { success: true, status: 200, caller: 'api.js>decryptClientApikey', 
            data: { apikey: apikey, expiration: expiration } };   
};

