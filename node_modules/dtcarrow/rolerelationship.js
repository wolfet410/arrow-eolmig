// Library code specifically for user api code
var Arrow = require('arrow'),
    Q = require('q'),
    Dtcarrow = require('dtcarrow'),
    _ = require('lodash');

// Helpers
module.exports.getType = function(roles) {
    // Parses an array of of roles objects, and returns the type as a 
    // string in either 'Admin', 'Coach', or 'Player'

    // Using a promise to handle the error response better
    var deferred = Q.defer();

    var l = roles.length;
    if (l === 0) {
        deferred.reject({ success: false, status: 422, caller: 'rolerelationship.js>getType', data: 'No roles returned' });
        return deferred.promise;
    }

    var found = false;
    for (var i = 0; i < l; i++) {
        if (roles[i].type !== 'N/A') {
            deferred.resolve({ success: true, status: 200, caller: 'rolerelationship.js>getType',
                data: roles[i].type });
            found = true;
            break;
        }
    }

    if (!found) {
        deferred.reject({ success: false, status: 404, caller: 'rolerelationship.js>getType',
            data: 'Type cannot be found' });
    }

    return deferred.promise;
};

module.exports.sanitizeRoles = function(roles) {
    // Reads array of roles, and removes any roles that are listed in the Role table with type Admin
    var deferred = Q.defer();
    if (roles.length === 0) {
        deferred.reject({ success: false, status: 422, caller: 'rolerelationship.js>sanitizeRoles',
            data: 'Bad input' });
        return deferred.promise;
    }

    var newRoles = [];

    Dtcarrow.Role.readAll()
        .then(function(readAllResult) {
            // lodash is too old to do anything useful here, maybe if we are able to upgrade it later this can 
            // be cleaned up
            roles.forEach(function(role) {
                readAllResult.data.forEach(function(dbRole) {
                    if (role.roleId === dbRole.roleId) {
                        if (dbRole.type !== 'Admin') {
                            newRoles.push(role);
                        }
                    }
                });
            });

            deferred.resolve({ success: true, status: 200, caller: 'rolerelationship.js>sanitizeRoles',
                data: newRoles });
        })
        .fail(function(err) {
            deferred.reject({ success: false, status: 500, caller: 'rolerelationship.js>sanitizeRoles', 
                data: err });
        });

    return deferred.promise;
}

// CRUD
module.exports.create = function(user) {
    // Writes roles to the UserRole table, returns user details on success
    var deferred = Q.defer();

    // Adding General User role to the user's roles, if it's not already listed in the user object    
    if (user.roles.length > 0) {
        var found = false;
        user.roles.forEach(function(r) {
            if (r.roleId === 2) {
                found = true;
            }
        });
        if (!found) {
            user.roles.push({ roleId: 2, selected: true });
        }
    } else {
        user.roles.push({ roleId: 2, selected: true });
    }

    var Model = Arrow.getModel('appc.mysql.eolmig/UserRole');
    var query = 'INSERT INTO UserRole (userId, roleId) VALUES ';
    user.roles.forEach(function(r) {
        query += '(' + user.userId + ',' + r.roleId + '),'
    });
    query = query.substring(0, query.length - 1);

    Model.query({ customSqlQuery: query }, function(err, results) {
        if (err) {
            deferred.reject({ success: false, status: 500, caller: 'rolerelationship.js>create',
                data: err });
            return deferred.promise;
        }

        deferred.resolve({ success: true, status: 201, caller: 'rolerelationship.js>create', 
            data: user });
    });

    return deferred.promise;
};

module.exports.read = function(user) {
    // Adds rows to user object, and returns new user object with roles
    // NOTE: This method doesn't reallly follow the expected format!!
    var deferred = Q.defer();

    var Model = Arrow.getModel('appc.mysql.eolmig/UserRole');
    var query = 'SELECT UserRole.roleId, Role.description, Role.type FROM UserRole, Role '
              + 'WHERE UserRole.roleId = Role.roleId AND userId = ' + user.userId;
    Model.query({ customSqlQuery: query }, function(err, userroleresults) {
        if (err) {
            deferred.reject({ success: false, status: 500, caller: 'rolerelationship.js>read',
                data: err });
            return deferred.promise;
        }

        if (typeof userroleresults === 'undefined' || userroleresults.length === 0) {
            // Users must have at least one role assigned to them
            deferred.reject({ success: false, status: 422, caller: 'rolerelationship.js>read', 
                data: 'No roles assigned to a user' });
            return deferred.promise;
        }

        user.roles = [];
        user.roleDescriptions = []; // Used for formatted list of roles on some user screens
        userroleresults.forEach(function(role) {
            user.roles.push({ roleId: role.roleId, description: role.description, type: role.type });
            if (role.type !== 'N/A') { user.roleDescriptions.push(role.description); }
        });

        deferred.resolve({ success: true, status: 200, caller: 'rolerelationship.js>read', 
            data: user });
    });

    return deferred.promise;
};

module.exports.delete = function(user) {
    // Delete the user's existing roles
    // NOTE: This method doesn't reallly follow the expected format!!
    var deferred = Q.defer();

    var Model = Arrow.getModel('appc.mysql.eolmig/UserRole');

    // Delete the user's old roles
    var query = 'DELETE FROM UserRole WHERE userId = ' + user.userId;
    Model.query({ customSqlQuery: query }, function(err, deleteResults) {
        if (err) {
            deferred.reject({ success: false, status: 500, caller: 'rolerelationship.js>delete',
                data: err });
            return deferred.promise;
        }

        deferred.resolve({ success: true, status: 200, caller: 'rolerelationship.js>delete', 
            data: user });
    });

    return deferred.promise;
}
